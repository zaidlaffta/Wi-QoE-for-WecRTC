Step-by-Step: Collecting QoE from Jitsi Meet
1. Join or Start a Meeting
Go to https://meet.jit.si or your self-hosted instance.

Create or join a room.

Make sure you and at least one other participant have both camera and mic ON.

2. Open Chrome DevTools
On your keyboard, press: Cmd + Option + J (Mac)

Ctrl + Shift + J or F12 (Windows/Linux)

Go to the Console tab.

3. Paste and Run the Sampling Script
Use the script below to log QoE metrics every 5 seconds.


////////////////////////////////////////////////////////
// --- Minimal QoE metrics collection and CSV export for Jitsi Meet ---
let lastVideoSent = 0, lastVideoRecv = 0, lastTimestamp = 0;
let sampleCount = 0;
let qoeSamples = [];

async function sampleQoE() {
  const pcMap = APP.conference._room.rtc.peerConnections;
  let pcs = [];
  for (const lp of pcMap.values()) {
    if (lp && lp.peerconnection) pcs.push(lp.peerconnection);
  }
  if (pcs.length === 0) {
    console.warn("No peer connections found. Is the call active?");
    return;
  }

  const pc = pcs[0];
  const stats = await pc.getStats();

  // Find necessary stats
  let videoSent = 0, videoRecv = 0, audioJitter = 0, audioLost = 0;
  for (const stat of stats.values()) {
    if (stat.type === "outbound-rtp" && stat.kind === "video" && stat.packetsSent !== undefined) {
      videoSent = stat.packetsSent;
    }
    if (stat.type === "inbound-rtp" && stat.kind === "video" && stat.packetsReceived !== undefined) {
      videoRecv = stat.packetsReceived;
    }
    if (stat.type === "inbound-rtp" && stat.kind === "audio") {
      audioJitter = stat.jitter ?? 0;
      audioLost = stat.packetsLost ?? 0;
    }
  }

  // Calculate per-second packet rates
  let now = Date.now();
  let sentPerSec = 0, recvPerSec = 0;
  if (sampleCount > 0 && lastTimestamp > 0) {
    let secs = (now - lastTimestamp) / 1000;
    sentPerSec = secs > 0 ? (videoSent - lastVideoSent) / secs : 0;
    recvPerSec = secs > 0 ? (videoRecv - lastVideoRecv) / secs : 0;
  }
  lastVideoSent = videoSent;
  lastVideoRecv = videoRecv;
  lastTimestamp = now;
  sampleCount++;

  // Compute QoE only after first sample
  let qoe = null;
  if (sampleCount > 1) {
    qoe = 3.420
      + 0.005 * sentPerSec
      - 72.898 * audioJitter
      - 0.001 * audioLost
      + 0.004 * recvPerSec;
    qoe = qoe.toFixed(3);
  }

  // Store data
  if (sampleCount > 1) qoeSamples.push({
    timestamp: new Date(now).toISOString(),
    VideoStream_PacketsSentPerSec: sentPerSec.toFixed(2),
    VideoStream_PacketsReceivedPerSec: recvPerSec.toFixed(2),
    AudioStream_Jitter: audioJitter,
    AudioStream_PacketsLost: audioLost,
    QoE: qoe
  });

  // Print each row for visibility
  console.log(qoeSamples[qoeSamples.length - 1]);
}

// To start sampling every second:
let interval = setInterval(sampleQoE, 1000);
// To stop sampling: clearInterval(interval);

// Download CSV file of all samples
function downloadQoECsv() {
  if (!qoeSamples.length) {
    console.warn("No QoE samples collected yet.");
    return;
  }
  const keys = Object.keys(qoeSamples[0]);
  const csvRows = [
    keys.join(','), // header
    ...qoeSamples.map(s => keys.map(k => s[k]).join(','))
  ];
  const csvContent = csvRows.join('\n');
  const blob = new Blob([csvContent], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `jitsi_qoe_samples_${Date.now()}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  console.log("CSV download triggered.");
}

// Usage:
// Start sampling:  
let interval = setInterval(sampleQoE, 4000);
// Stop sampling:    
clearInterval(interval);
// Download CSV:    
downloadQoECsv();


